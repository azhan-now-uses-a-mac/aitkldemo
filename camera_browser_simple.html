<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Camera Browser - Simple Face Detection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .camera-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 800px;
            width: 100%;
        }

        .video-wrapper {
            position: relative;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        .video-container {
            position: relative;
            display: inline-block;
        }

        #videoElement {
            width: 100%;
            max-width: 90vw;
            aspect-ratio: 16/9;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: block;
            object-fit: cover;
        }

        #canvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 15px;
            pointer-events: none;
            z-index: 10;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button.active {
            background: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .status {
            text-align: center;
            padding: 15px;
            margin-top: 20px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .success {
            background: rgba(46, 204, 113, 0.3);
            border-color: rgba(46, 204, 113, 0.5);
        }

        .error {
            background: rgba(255, 82, 82, 0.3);
            border-color: rgba(255, 82, 82, 0.5);
        }

        .detection-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ü§ñ Simple Face Detection Camera</h1>
        <p>Lightweight face detection using HTML5 Canvas</p>
    </div>

    <div class="camera-container">
        <div class="video-wrapper">
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="canvasElement"></canvas>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn">üìπ Start Camera</button>
            <button id="stopBtn" disabled>‚èπÔ∏è Stop Camera</button>
            <button id="trackingBtn">üéØ Toggle Motion Detection</button>
            <button id="calibrateBtn">üìè Calibrate Distance</button>
            <button id="resetBtn">üîÑ Reset</button>
        </div>

        <div id="status" class="status">
            Ready to start camera with simple motion/face detection.
        </div>

        <div id="detectionInfo" class="detection-info" style="display: none;">
            <strong>Detection Info:</strong><br>
            <span id="motionLevel">Motion: 0%</span><br>
            <span id="faceRegions">Face Regions: 0</span>
        </div>
    </div>

    <script>
        class SimpleFaceDetectionCamera {
            constructor() {
                this.video = document.getElementById('videoElement');
                this.canvas = document.getElementById('canvasElement');
                this.ctx = this.canvas.getContext('2d');
                this.status = document.getElementById('status');
                this.detectionInfo = document.getElementById('detectionInfo');
                this.stream = null;
                this.trackingActive = false;
                this.animationFrame = null;
                
                // Motion detection variables
                this.previousFrame = null;
                this.motionThreshold = 30;
                this.faceRegions = [];
                
                // Distance estimation parameters
                this.averageFaceWidth = 140; // Average face width in mm
                this.focalLength = 500; // Estimated focal length
                this.calibrationDistance = 60; // Calibration distance in cm
                this.isCalibrated = false;
                
                this.initializeControls();
            }

            initializeControls() {
                document.getElementById('startBtn').addEventListener('click', () => this.startCamera());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopCamera());
                document.getElementById('trackingBtn').addEventListener('click', () => this.toggleTracking());
                document.getElementById('calibrateBtn').addEventListener('click', () => this.calibrateDistance());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
            }

            async startCamera() {
                try {
                    this.updateStatus('üîÑ Requesting camera access...', 'status');
                    
                    const constraints = {
                        video: {
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            facingMode: 'user'
                        },
                        audio: false
                    };

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    
                    this.video.onloadedmetadata = () => {
                        this.video.play();
                        this.setupCanvas();
                        this.updateStatus('‚úÖ Camera active! Click "Toggle Motion Detection" to start tracking', 'success');
                        document.getElementById('startBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                    };

                } catch (error) {
                    console.error('Camera access error:', error);
                    this.updateStatus('‚ùå Camera access failed: ' + error.message, 'error');
                }
            }

            setupCanvas() {
                // Set canvas size to match video
                this.canvas.width = this.video.videoWidth || 640;
                this.canvas.height = this.video.videoHeight || 480;
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                    this.video.srcObject = null;
                    
                    this.stopTracking();
                    this.updateStatus('‚èπÔ∏è Camera stopped', 'status');
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                }
            }

            toggleTracking() {
                this.trackingActive = !this.trackingActive;
                const trackingBtn = document.getElementById('trackingBtn');
                
                if (this.trackingActive) {
                    trackingBtn.classList.add('active');
                    trackingBtn.textContent = 'üéØ Stop Detection';
                    this.startTracking();
                    this.updateStatus('üéØ Motion/Face detection enabled', 'success');
                    this.detectionInfo.style.display = 'block';
                } else {
                    trackingBtn.classList.remove('active');
                    trackingBtn.textContent = 'üéØ Start Detection';
                    this.stopTracking();
                    this.updateStatus('‚è∏Ô∏è Detection disabled', 'status');
                    this.detectionInfo.style.display = 'none';
                }
            }

            startTracking() {
                if (!this.trackingActive) return;
                
                this.detectMotionAndFaces();
                this.animationFrame = requestAnimationFrame(() => this.startTracking());
            }

            stopTracking() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.previousFrame = null;
            }

            detectMotionAndFaces() {
                if (!this.video.videoWidth || !this.video.videoHeight) return;
                
                // Update canvas size if needed
                if (this.canvas.width !== this.video.videoWidth) {
                    this.setupCanvas();
                }
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Get current frame
                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                const currentFrame = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                
                let motionLevel = 0;
                
                if (this.previousFrame) {
                    motionLevel = this.calculateMotion(currentFrame, this.previousFrame);
                    this.drawMotionDetection(currentFrame, motionLevel);
                }
                
                // Simple face region detection using skin color and symmetry
                this.faceRegions = this.detectFaceRegions(currentFrame);
                this.drawFaceRegions();
                
                // Update info display
                document.getElementById('motionLevel').textContent = `Motion: ${Math.round(motionLevel)}%`;
                document.getElementById('faceRegions').textContent = `Face Regions: ${this.faceRegions.length}`;
                
                this.previousFrame = currentFrame;
            }

            calculateMotion(current, previous) {
                const threshold = this.motionThreshold;
                let motionPixels = 0;
                const totalPixels = current.width * current.height;
                
                for (let i = 0; i < current.data.length; i += 4) {
                    const diff = Math.abs(current.data[i] - previous.data[i]) +
                                Math.abs(current.data[i + 1] - previous.data[i + 1]) +
                                Math.abs(current.data[i + 2] - previous.data[i + 2]);
                    
                    if (diff > threshold) {
                        motionPixels++;
                    }
                }
                
                return (motionPixels / totalPixels) * 100;
            }

            drawMotionDetection(frame, motionLevel) {
                if (motionLevel > 5) { // Significant motion detected
                    this.ctx.strokeStyle = '#ff4444';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(10, 10, this.canvas.width - 20, this.canvas.height - 20);
                    
                    this.ctx.fillStyle = '#ff4444';
                    this.ctx.font = '16px Arial';
                    this.ctx.fillText(`Motion: ${Math.round(motionLevel)}%`, 20, 40);
                }
            }

            detectFaceRegions(frame) {
                const regions = [];
                const width = frame.width;
                const height = frame.height;
                const data = frame.data;
                
                // Simple face detection using skin color detection and region analysis
                const skinRegions = this.detectSkinRegions(data, width, height);
                
                // Filter regions that could be faces (size, aspect ratio, position)
                skinRegions.forEach(region => {
                    const aspectRatio = region.width / region.height;
                    const area = region.width * region.height;
                    
                    // Face-like characteristics
                    if (aspectRatio > 0.7 && aspectRatio < 1.5 && // Face aspect ratio
                        area > 2000 && area < 50000 && // Reasonable size
                        region.y < height * 0.8) { // Not at bottom of frame
                        regions.push(region);
                    }
                });
                
                return regions;
            }

            detectSkinRegions(data, width, height) {
                const regions = [];
                const visited = new Array(width * height).fill(false);
                
                for (let y = 0; y < height; y += 5) { // Sample every 5 pixels for performance
                    for (let x = 0; x < width; x += 5) {
                        const index = (y * width + x) * 4;
                        
                        if (!visited[y * width + x] && this.isSkinColor(data[index], data[index + 1], data[index + 2])) {
                            const region = this.floodFillRegion(data, width, height, x, y, visited);
                            if (region.width > 20 && region.height > 20) {
                                regions.push(region);
                            }
                        }
                    }
                }
                
                return regions;
            }

            isSkinColor(r, g, b) {
                // Simple skin color detection in RGB space
                return r > 95 && g > 40 && b > 20 &&
                       r > g && r > b &&
                       Math.abs(r - g) > 15 &&
                       Math.max(r, g, b) - Math.min(r, g, b) > 15;
            }

            floodFillRegion(data, width, height, startX, startY, visited) {
                const stack = [{x: startX, y: startY}];
                let minX = startX, maxX = startX, minY = startY, maxY = startY;
                let pixelCount = 0;
                
                while (stack.length > 0 && pixelCount < 1000) { // Limit for performance
                    const {x, y} = stack.pop();
                    
                    if (x < 0 || x >= width || y < 0 || y >= height) continue;
                    if (visited[y * width + x]) continue;
                    
                    const index = (y * width + x) * 4;
                    if (!this.isSkinColor(data[index], data[index + 1], data[index + 2])) continue;
                    
                    visited[y * width + x] = true;
                    pixelCount++;
                    
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                    
                    // Add neighbors
                    stack.push({x: x + 1, y}, {x: x - 1, y}, {x, y: y + 1}, {x, y: y - 1});
                }
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY,
                    pixelCount
                };
            }

            drawFaceRegions() {
                this.ctx.lineWidth = 2;
                this.ctx.font = '14px Arial';
                
                this.faceRegions.forEach((region, index) => {
                    // Calculate distance estimate
                    const distance = this.calculateDistance(region.width);
                    
                    // Color code based on distance
                    if (distance) {
                        if (distance < 50) {
                            this.ctx.strokeStyle = '#ff0000'; // Red for very close
                            this.ctx.fillStyle = '#ff0000';
                        } else if (distance < 100) {
                            this.ctx.strokeStyle = '#ffaa00'; // Orange for close
                            this.ctx.fillStyle = '#ffaa00';
                        } else if (distance < 200) {
                            this.ctx.strokeStyle = '#00ff00'; // Green for normal
                            this.ctx.fillStyle = '#00ff00';
                        } else {
                            this.ctx.strokeStyle = '#0088ff'; // Blue for far
                            this.ctx.fillStyle = '#0088ff';
                        }
                    } else {
                        this.ctx.strokeStyle = '#00ff00';
                        this.ctx.fillStyle = '#00ff00';
                    }
                    
                    // Draw bounding box
                    this.ctx.strokeRect(region.x, region.y, region.width, region.height);
                    
                    // Draw label with distance
                    const distanceText = distance ? ` (${Math.round(distance)}cm)` : '';
                    this.ctx.fillText(`Face ${index + 1}${distanceText}`, region.x, region.y - 20);
                    
                    // Draw distance indicator
                    if (distance) {
                        const indicator = this.getDistanceIndicator(distance);
                        this.ctx.fillText(indicator, region.x, region.y - 5);
                    }
                    
                    // Draw center point
                    const centerX = region.x + region.width / 2;
                    const centerY = region.y + region.height / 2;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
            }

            calculateDistance(faceWidthInPixels) {
                if (!faceWidthInPixels || faceWidthInPixels < 10) return null;
                
                const distance = (this.averageFaceWidth * this.focalLength) / faceWidthInPixels;
                return distance / 10; // Convert mm to cm
            }

            calibrateDistance() {
                if (!this.faceRegions || this.faceRegions.length === 0) {
                    this.updateStatus('‚ùå No faces detected for calibration. Enable tracking first.', 'error');
                    return;
                }

                // Use the largest face for calibration
                const largestFace = this.faceRegions.reduce((largest, face) => {
                    return face.width > largest.width ? face : largest;
                });

                // Calculate focal length based on known distance
                this.focalLength = (largestFace.width * this.calibrationDistance * 10) / this.averageFaceWidth;
                this.isCalibrated = true;

                const calibrateBtn = document.getElementById('calibrateBtn');
                calibrateBtn.classList.add('active');
                calibrateBtn.textContent = '‚úÖ Calibrated';

                this.updateStatus(`‚úÖ Distance calibrated at ${this.calibrationDistance}cm!`, 'success');
            }

            getDistanceIndicator(distance) {
                if (distance < 30) return 'üî¥ Too Close!';
                if (distance < 50) return 'üü† Very Close';
                if (distance < 100) return 'üü° Close';
                if (distance < 200) return 'üü¢ Good Distance';
                if (distance < 300) return 'üîµ Far';
                return 'üü£ Very Far';
            }

            reset() {
                this.stopTracking();
                this.previousFrame = null;
                this.faceRegions = [];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.updateStatus('üîÑ Detection reset', 'status');
            }

            updateStatus(message, className = 'status') {
                this.status.textContent = message;
                this.status.className = `status ${className}`;
            }
        }

        // Initialize the camera when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SimpleFaceDetectionCamera();
        });
    </script>
</body>
</html>
