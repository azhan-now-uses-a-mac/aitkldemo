<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî¥ Red Cap Follower Robot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 20%, #16213e 50%, #0f3460 80%, #1a1a2e 100%);
            background-attachment: fixed;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: #e0e0e0;
            margin: 0;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 20px rgba(255, 0, 0, 0.3);
            background: linear-gradient(45deg, #ff0000, #ff6666);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .camera-container {
            background: rgba(20, 20, 35, 0.8);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 95vw;
            width: 100%;
        }

        .video-wrapper {
            position: relative;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        .video-container {
            position: relative;
            display: inline-block;
        }

        #videoElement {
            width: 100%;
            max-width: 90vw;
            aspect-ratio: 16/9;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: block;
            object-fit: cover;
        }

        #canvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 15px;
            pointer-events: none;
            z-index: 10;
        }

        .status-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 15;
            max-width: 250px;
        }

        .distance-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            z-index: 15;
            border: 2px solid #00ff00;
            text-align: center;
            min-width: 150px;
        }

        .distance-overlay.too-close {
            border-color: #ff0000;
            color: #ff4444;
        }

        .distance-overlay.perfect {
            border-color: #00ff00;
            color: #00ff00;
        }

        .distance-overlay.too-far {
            border-color: #ffaa00;
            color: #ffaa00;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        button {
            background: linear-gradient(145deg, #2a2a3e, #1e1e2e);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        button:hover {
            background: linear-gradient(145deg, #3a3a4e, #2e2e3e);
            transform: translateY(-1px);
        }

        button.active {
            background: linear-gradient(145deg, #ff0000, #cc0000);
            color: #fff;
        }

        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .setting-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(90deg, #1e1e2e, #2a2a3e);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(145deg, #ff0000, #cc0000);
            cursor: pointer;
        }

        .status {
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            background: rgba(20, 20, 35, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            font-size: 14px;
        }

        .success {
            background: rgba(0, 255, 0, 0.1);
            border-color: rgba(0, 255, 0, 0.3);
            color: #00ff00;
        }

        .error {
            background: rgba(255, 0, 0, 0.1);
            border-color: rgba(255, 0, 0, 0.3);
            color: #ff6464;
        }

        .warning {
            background: rgba(255, 170, 0, 0.1);
            border-color: rgba(255, 170, 0, 0.3);
            color: #ffaa00;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .camera-container {
                padding: 15px;
                margin: 5px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 180px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üî¥ Red Cap Follower Robot</h1>
        <p>AI-powered red object tracking with distance-based following</p>
    </div>

    <div class="camera-container">
        <div class="video-wrapper">
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="canvasElement"></canvas>
                <div id="statusOverlay" class="status-overlay">
                    <div>üîç Searching for red cap...</div>
                    <div id="detectionInfo">No red objects detected</div>
                </div>
                <div id="distanceOverlay" class="distance-overlay" style="display: none;">
                    <div id="distanceText">Measuring...</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn">üìπ Start Camera</button>
            <button id="stopBtn" disabled>‚èπÔ∏è Stop Camera</button>
            <button id="trackingBtn">üéØ Start Tracking</button>
            <button id="followingBtn">ü§ñ Start Following</button>
            <button id="calibrateBtn">üìè Calibrate Distance</button>
            <button id="voiceBtn">üé§ Voice Control</button>
            <button id="resetBtn">üîÑ Reset</button>
        </div>

        <div class="settings">
            <div class="setting-group">
                <label for="redSensitivity">üî¥ Red Sensitivity: <span id="redSensitivityValue">40</span></label>
                <input type="range" id="redSensitivity" min="10" max="100" value="40">
            </div>
            <div class="setting-group">
                <label for="minObjectSize">üìè Min Object Size: <span id="minObjectSizeValue">500</span></label>
                <input type="range" id="minObjectSize" min="100" max="2000" value="500">
            </div>
            <div class="setting-group">
                <label for="followDistance">üéØ Follow Distance: <span id="followDistanceValue">50</span>cm</label>
                <input type="range" id="followDistance" min="30" max="150" value="50">
            </div>
            <div class="setting-group">
                <label for="robotSpeed">‚ö° Robot Speed: <span id="robotSpeedValue">1500</span></label>
                <input type="range" id="robotSpeed" min="500" max="3000" value="1500">
            </div>
        </div>

        <div id="status" class="status">
            Ready to start red cap following. Click "Start Camera" to begin.
        </div>
    </div>

    <script>
        class RedCapFollower {
            constructor() {
                this.video = document.getElementById('videoElement');
                this.canvas = document.getElementById('canvasElement');
                this.ctx = this.canvas.getContext('2d');
                this.status = document.getElementById('status');
                this.stream = null;
                this.trackingActive = false;
                this.followingActive = false;
                this.animationFrame = null;
                
                // Red detection parameters
                this.redSensitivity = 40;
                this.minObjectSize = 500;
                this.detectedRedObjects = [];
                
                // Distance and following parameters
                this.followDistance = 50; // cm
                this.robotSpeed = 1500;
                this.averageCapWidth = 200; // Average cap width in mm
                this.focalLength = 500; // Camera focal length (estimated)
                this.isCalibrated = false;
                this.calibrationDistance = 100; // cm
                
                // Robot control state
                this.lastCommand = null;
                this.commandCooldown = 400; // ms between commands (smoother, slower movements)
                this.lastCommandTime = 0;
                
                // WebSocket connection for real-time robot control
                this.websocket = null;
                this.robotConnected = false;
                
                // Voice control
                this.voiceActive = false;
                this.recognition = null;
                this.audioContext = null;
                
                this.initializeControls();
                this.initializeSettings();
                this.initializeRobotConnection();
            }

            initializeControls() {
                document.getElementById('startBtn').addEventListener('click', () => this.startCamera());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopCamera());
                document.getElementById('trackingBtn').addEventListener('click', () => this.toggleTracking());
                document.getElementById('followingBtn').addEventListener('click', () => this.toggleFollowing());
                document.getElementById('calibrateBtn').addEventListener('click', () => this.calibrateDistance());
                document.getElementById('voiceBtn').addEventListener('click', () => this.toggleVoiceControl());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
            }

            initializeSettings() {
                const settings = [
                    { id: 'redSensitivity', property: 'redSensitivity' },
                    { id: 'minObjectSize', property: 'minObjectSize' },
                    { id: 'followDistance', property: 'followDistance' },
                    { id: 'robotSpeed', property: 'robotSpeed' }
                ];
                
                settings.forEach(setting => {
                    const slider = document.getElementById(setting.id);
                    const valueDisplay = document.getElementById(setting.id + 'Value');
                    
                    slider.addEventListener('input', (e) => {
                        const value = parseInt(e.target.value);
                        this[setting.property] = value;
                        
                        const unit = setting.id === 'followDistance' ? 'cm' : '';
                        valueDisplay.textContent = value + unit;
                    });
                });
            }

            async startCamera() {
                try {
                    this.updateStatus('üîÑ Starting camera...', 'status');
                    
                    const constraints = {
                        video: {
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            facingMode: 'user'
                        },
                        audio: false
                    };

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    
                    this.video.onloadedmetadata = () => {
                        this.video.play();
                        this.setupCanvas();
                        this.updateStatus('‚úÖ Camera ready! Click "Start Tracking" to detect red objects', 'success');
                        document.getElementById('startBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                    };

                } catch (error) {
                    console.error('Camera error:', error);
                    this.updateStatus('‚ùå Camera access failed: ' + error.message, 'error');
                }
            }

            setupCanvas() {
                this.canvas.width = this.video.offsetWidth;
                this.canvas.height = this.video.offsetHeight;
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                    this.video.srcObject = null;
                    
                    this.stopTracking();
                    this.stopFollowing();
                    this.updateStatus('‚èπÔ∏è Camera stopped', 'status');
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                }
            }

            toggleTracking() {
                this.trackingActive = !this.trackingActive;
                const trackingBtn = document.getElementById('trackingBtn');
                
                if (this.trackingActive) {
                    trackingBtn.classList.add('active');
                    trackingBtn.textContent = 'üéØ Stop Tracking';
                    this.startTracking();
                    this.updateStatus('üéØ Red object tracking enabled', 'success');
                } else {
                    trackingBtn.classList.remove('active');
                    trackingBtn.textContent = 'üéØ Start Tracking';
                    this.stopTracking();
                    this.updateStatus('‚è∏Ô∏è Tracking disabled', 'status');
                }
            }

            toggleFollowing() {
                this.followingActive = !this.followingActive;
                const followingBtn = document.getElementById('followingBtn');
                
                if (this.followingActive) {
                    if (!this.trackingActive) {
                        this.updateStatus('‚ùå Start tracking first before following!', 'error');
                        return;
                    }
                    followingBtn.classList.add('active');
                    followingBtn.textContent = 'ü§ñ Stop Following';
                    this.updateStatus('ü§ñ Robot following enabled! Keep red cap visible', 'success');
                } else {
                    followingBtn.classList.remove('active');
                    followingBtn.textContent = 'ü§ñ Start Following';
                    this.sendRobotCommand('stop');
                    this.updateStatus('‚è∏Ô∏è Following disabled', 'status');
                }
            }

            startTracking() {
                if (!this.trackingActive) return;
                
                this.detectRedObjects();
                this.animationFrame = requestAnimationFrame(() => this.startTracking());
            }

            stopTracking() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.detectedRedObjects = [];
                this.hideDistanceOverlay();
            }

            stopFollowing() {
                this.followingActive = false;
                const followingBtn = document.getElementById('followingBtn');
                followingBtn.classList.remove('active');
                followingBtn.textContent = 'ü§ñ Start Following';
                this.sendRobotCommand('stop');
            }

            detectRedObjects() {
                if (!this.video.videoWidth || !this.video.videoHeight) return;
                
                // Update canvas size if needed
                if (this.canvas.width !== this.video.offsetWidth) {
                    this.setupCanvas();
                }
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Create temporary canvas for analysis
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.video.videoWidth;
                tempCanvas.height = this.video.videoHeight;
                
                // Draw video frame
                tempCtx.drawImage(this.video, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                
                // Detect red objects
                this.detectedRedObjects = this.findRedObjects(imageData);
                
                // Draw detections
                this.drawDetections();
                
                // Update status
                this.updateDetectionInfo();
                
                // Control robot if following is active
                if (this.followingActive && this.detectedRedObjects.length > 0) {
                    this.controlRobot();
                }
            }

            findRedObjects(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const redMask = new Uint8Array(width * height);
                
                // Create red object mask
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Enhanced red detection
                    const isRed = this.isRedPixel(r, g, b);
                    const pixelIndex = Math.floor(i / 4);
                    redMask[pixelIndex] = isRed ? 255 : 0;
                }
                
                // Find connected components
                return this.findConnectedComponents(redMask, width, height);
            }

            isRedPixel(r, g, b) {
                // Multiple red detection methods for better accuracy
                const method1 = r > 100 && r > g * 1.5 && r > b * 1.5; // Basic red
                const method2 = r > 120 && g < 80 && b < 80; // Pure red
                const method3 = (r - g) > this.redSensitivity && (r - b) > this.redSensitivity; // Red dominance
                
                return method1 || method2 || method3;
            }

            findConnectedComponents(mask, width, height) {
                const visited = new Uint8Array(width * height);
                const objects = [];
                
                for (let y = 0; y < height; y += 2) { // Skip pixels for performance
                    for (let x = 0; x < width; x += 2) {
                        const index = y * width + x;
                        
                        if (mask[index] && !visited[index]) {
                            const component = this.floodFill(mask, visited, width, height, x, y);
                            
                            if (component.area > this.minObjectSize) {
                                objects.push(component);
                            }
                        }
                    }
                }
                
                // Sort by size (largest first)
                return objects.sort((a, b) => b.area - a.area);
            }

            floodFill(mask, visited, width, height, startX, startY) {
                const stack = [{x: startX, y: startY}];
                let minX = startX, maxX = startX, minY = startY, maxY = startY;
                let area = 0;
                
                while (stack.length > 0) {
                    const {x, y} = stack.pop();
                    
                    if (x < 0 || x >= width || y < 0 || y >= height) continue;
                    
                    const index = y * width + x;
                    if (visited[index] || !mask[index]) continue;
                    
                    visited[index] = 1;
                    area++;
                    
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                    
                    // Add neighbors
                    stack.push({x: x + 1, y}, {x: x - 1, y}, {x, y: y + 1}, {x, y: y - 1});
                }
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY,
                    centerX: (minX + maxX) / 2,
                    centerY: (minY + maxY) / 2,
                    area: area
                };
            }

            drawDetections() {
                const scaleX = this.canvas.width / this.video.videoWidth;
                const scaleY = this.canvas.height / this.video.videoHeight;
                
                this.detectedRedObjects.forEach((obj, index) => {
                    const x = obj.x * scaleX;
                    const y = obj.y * scaleY;
                    const width = obj.width * scaleX;
                    const height = obj.height * scaleY;
                    const centerX = obj.centerX * scaleX;
                    const centerY = obj.centerY * scaleY;
                    
                    // Calculate distance
                    const distance = this.calculateDistance(obj.width);
                    
                    // Color based on distance
                    let color = '#00ff00';
                    if (distance) {
                        if (distance < this.followDistance * 0.7) {
                            color = '#ff0000'; // Too close
                        } else if (distance > this.followDistance * 1.5) {
                            color = '#ffaa00'; // Too far
                        }
                    }
                    
                    // Draw bounding box
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(x, y, width, height);
                    
                    // Draw center point
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Draw crosshair
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX - 15, centerY);
                    this.ctx.lineTo(centerX + 15, centerY);
                    this.ctx.moveTo(centerX, centerY - 15);
                    this.ctx.lineTo(centerX, centerY + 15);
                    this.ctx.stroke();
                    
                    // Draw label
                    this.ctx.font = '16px Arial';
                    this.ctx.fillText(`Red Cap ${index + 1}`, x, y - 20);
                    
                    if (distance) {
                        this.ctx.fillText(`${Math.round(distance)}cm`, x, y - 5);
                    }
                    
                    // Update distance overlay for primary target
                    if (index === 0) {
                        this.updateDistanceOverlay(distance);
                    }
                });
                
                if (this.detectedRedObjects.length === 0) {
                    this.hideDistanceOverlay();
                }
            }

            calculateDistance(objectWidthInPixels) {
                if (!objectWidthInPixels || objectWidthInPixels < 10) return null;
                
                const distance = (this.averageCapWidth * this.focalLength) / objectWidthInPixels;
                return distance / 10; // Convert mm to cm
            }

            updateDistanceOverlay(distance) {
                const overlay = document.getElementById('distanceOverlay');
                const text = document.getElementById('distanceText');
                
                if (!distance) {
                    overlay.style.display = 'none';
                    return;
                }
                
                overlay.style.display = 'block';
                
                // Remove all classes
                overlay.classList.remove('too-close', 'perfect', 'too-far');
                
                const targetDistance = this.followDistance;
                const tolerance = 15; // Same 15cm tolerance as movement logic
                
                if (distance < targetDistance - tolerance) {
                    text.innerHTML = `<div>üî¥ TOO CLOSE</div><div>${Math.round(distance)}cm (target: ${targetDistance}cm)</div>`;
                    overlay.classList.add('too-close');
                } else if (distance > targetDistance + tolerance) {
                    text.innerHTML = `<div>üü† TOO FAR</div><div>${Math.round(distance)}cm (target: ${targetDistance}cm)</div>`;
                    overlay.classList.add('too-far');
                } else {
                    text.innerHTML = `<div>‚úÖ PERFECT</div><div>${Math.round(distance)}cm (target: ${targetDistance}cm)</div>`;
                    overlay.classList.add('perfect');
                }
            }

            hideDistanceOverlay() {
                document.getElementById('distanceOverlay').style.display = 'none';
            }

            updateDetectionInfo() {
                const info = document.getElementById('detectionInfo');
                
                if (this.detectedRedObjects.length === 0) {
                    info.textContent = 'No red objects detected';
                } else {
                    const largest = this.detectedRedObjects[0];
                    const distance = this.calculateDistance(largest.width);
                    info.innerHTML = `Found ${this.detectedRedObjects.length} red object(s)<br>Largest: ${largest.area}px¬≤ ${distance ? `(${Math.round(distance)}cm)` : ''}`;
                }
            }

            controlRobot() {
                if (this.detectedRedObjects.length === 0) return;
                
                const now = Date.now();
                if (now - this.lastCommandTime < this.commandCooldown) return;
                
                const target = this.detectedRedObjects[0]; // Follow largest red object
                const distance = this.calculateDistance(target.width);
                
                if (!distance) return;
                
                const centerX = target.centerX;
                const frameWidth = this.video.videoWidth;
                const frameCenterX = frameWidth / 2;
                
                // Calculate horizontal offset
                const offsetX = centerX - frameCenterX;
                const offsetPercent = offsetX / frameCenterX;
                
                const targetDistance = this.followDistance;
                const tolerance = 15; // Fixed 15cm tolerance instead of percentage
                
                let command = null;
                
                console.log(`üéØ Distance: ${Math.round(distance)}cm, Target: ${targetDistance}cm, Offset: ${Math.round(offsetPercent * 100)}%`);
                
                // Distance control (forward/backward) - prioritize distance first
                if (distance < targetDistance - tolerance) {
                    command = 'backward';
                    console.log(`üì§ TOO CLOSE: Moving backward (${Math.round(distance)}cm < ${targetDistance - tolerance}cm)`);
                } else if (distance > targetDistance + tolerance) {
                    command = 'forward';
                    console.log(`üì§ TOO FAR: Moving forward (${Math.round(distance)}cm > ${targetDistance + tolerance}cm)`);
                } else {
                    // Good distance, adjust horizontal position
                    if (Math.abs(offsetPercent) > 0.15) { // Wider dead zone for stability
                        command = offsetPercent > 0 ? 'right' : 'left';
                        console.log(`üì§ CENTERING: Turning ${command} (offset: ${Math.round(offsetPercent * 100)}%)`);
                    } else {
                        command = 'stop';
                        console.log(`‚úÖ PERFECT: At target distance and centered`);
                    }
                }
                
                // Execute command if different from last
                if (command && command !== this.lastCommand) {
                    this.sendRobotCommand(command);
                    this.lastCommand = command;
                    this.lastCommandTime = now;
                }
            }

            initializeRobotConnection() {
                // Create a command server endpoint for robot communication
                this.commandServer = '/robot/execute';
                this.robotConnected = true; // Assume connected for direct execution
                
                console.log('ü§ñ Direct robot command integration initialized');
                this.updateStatus('ü§ñ Robot direct control ready!', 'success');
            }

            async sendRobotCommand(command) {
                console.log(`ü§ñ Executing robot command: ${command}`);
                
                // Map high-level commands to robot wheel commands (slower speeds)
                const commandMap = {
                    'forward': { left: -800, right: 800, desc: 'Moving forward slowly' },
                    'backward': { left: 800, right: -800, desc: 'Moving backward slowly' },
                    'left': { left: -600, right: -600, desc: 'Turning left slowly' },
                    'right': { left: 600, right: 600, desc: 'Turning right slowly' },
                    'stop': { left: 0, right: 0, desc: 'Stopping' }
                };
                
                const robotCmd = commandMap[command];
                if (!robotCmd) {
                    console.error(`‚ùå Unknown command: ${command}`);
                    return false;
                }
                
                try {
                    console.log(`ü§ñ ${robotCmd.desc}... (L:${robotCmd.left}, R:${robotCmd.right})`);
                    
                    // Execute robot command using server endpoint
                    const success = await this.executeRobotMovement(robotCmd.left, robotCmd.right);
                    
                    if (success) {
                        this.updateStatus(`ü§ñ ${robotCmd.desc}`, 'success');
                        
                        // Auto-stop after movement commands to prevent continuous motion
                        if (command !== 'stop') {
                            setTimeout(() => {
                                if (this.lastCommand === command) {
                                    this.executeRobotMovement(0, 0); // Stop
                                    console.log('üõë Auto-stop activated');
                                }
                            }, 300); // Stop after 300ms for gentle movements
                        }
                        
                        return true;
                    } else {
                        // Fallback to manual command display
                        const manualCmd = this.getManualCommand(command);
                        this.updateStatus(`ü§ñ Manual: Press '${manualCmd}' on interactive control`, 'warning');
                        return false;
                    }
                    
                } catch (error) {
                    console.error('‚ùå Robot command execution error:', error);
                    
                    // Show manual command as fallback
                    const manualCmd = this.getManualCommand(command);
                    this.updateStatus(`ü§ñ Manual: Press '${manualCmd}' on robot`, 'warning');
                    return false;
                }
            }
            
            async executeRobotMovement(leftSpeed, rightSpeed) {
                try {
                    // Try to use the server-side robot controller
                    const serverIP = window.location.hostname;
                    const controllerURL = `http://${serverIP}:8081/robot/dual_wheel`;
                    
                    console.log(`Sending to: ${controllerURL}, L:${leftSpeed}, R:${rightSpeed}`);
                    
                    const response = await fetch(controllerURL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        },
                        body: JSON.stringify({ 
                            left_speed: leftSpeed, 
                            right_speed: rightSpeed 
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log(`‚úÖ Server command executed successfully:`, result);
                        return true;
                    } else {
                        console.log(`‚ùå Server responded with error: ${response.status}`);
                    }
                } catch (error) {
                    console.log('‚ö†Ô∏è Server connection failed:', error);
                }
                
                // Fallback: Try to execute directly using server endpoint (if available)
                try {
                    // Create a simple fetch request to trigger server-side execution
                    const directURL = `/execute_robot_command?left=${leftSpeed}&right=${rightSpeed}`;
                    const response = await fetch(directURL, { 
                        method: 'GET',
                        timeout: 1000 
                    });
                    
                    console.log(`‚úÖ Direct command executed: L:${leftSpeed}, R:${rightSpeed}`);
                    return true;
                    
                } catch (error) {
                    console.log('‚ö†Ô∏è Direct execution not available');
                }
                
                // Final fallback: Display clear manual instructions with exact ADB commands
                console.log(`‚ùå Automatic robot control failed. Manual commands needed:`);
                console.log(`Run these commands on your computer:`);
                console.log(`adb shell "su -c 'cd /data/data/com.ohmnilabs.telebot_rtc/files/assets/node-files && echo \\"rot 0 ${leftSpeed}\\" | ./node bot_shell_client.js'"`);
                console.log(`adb shell "su -c 'cd /data/data/com.ohmnilabs.telebot_rtc/files/assets/node-files && echo \\"rot 1 ${rightSpeed}\\" | ./node bot_shell_client.js'"`);
                
                // Show prominent visual instruction for manual execution
                this.showManualCommand(leftSpeed, rightSpeed);
                
                return true; // Return true so following continues with manual instructions
            }
            
            getManualCommand(command) {
                const commandMap = {
                    'forward': 'w',
                    'backward': 's', 
                    'left': 'a',
                    'right': 'd',
                    'stop': 'q'
                };
                return commandMap[command] || command;
            }

            calibrateDistance() {
                if (this.detectedRedObjects.length === 0) {
                    this.updateStatus('‚ùå No red objects detected for calibration', 'error');
                    return;
                }
                
                const largest = this.detectedRedObjects[0];
                this.focalLength = (largest.width * this.calibrationDistance * 10) / this.averageCapWidth;
                this.isCalibrated = true;
                
                const btn = document.getElementById('calibrateBtn');
                btn.classList.add('active');
                btn.textContent = '‚úÖ Calibrated';
                
                this.updateStatus(`‚úÖ Distance calibrated at ${this.calibrationDistance}cm!`, 'success');
            }

            reset() {
                this.stopTracking();
                this.stopFollowing();
                this.detectedRedObjects = [];
                this.lastCommand = null;
                this.isCalibrated = false;
                
                const calibrateBtn = document.getElementById('calibrateBtn');
                calibrateBtn.classList.remove('active');
                calibrateBtn.textContent = 'üìè Calibrate Distance';
                
                this.updateStatus('üîÑ System reset complete', 'status');
            }

            showManualCommand(leftSpeed, rightSpeed) {
                // Create a prominent display for manual commands
                let commandText = '';
                if (leftSpeed === 0 && rightSpeed === 0) {
                    commandText = 'Press q (STOP)';
                } else if (leftSpeed < 0 && rightSpeed > 0) {
                    commandText = 'Press w (FORWARD)';
                } else if (leftSpeed > 0 && rightSpeed < 0) {
                    commandText = 'Press s (BACKWARD)';
                } else if (leftSpeed < 0 && rightSpeed < 0) {
                    commandText = 'Press a (LEFT)';
                } else if (leftSpeed > 0 && rightSpeed > 0) {
                    commandText = 'Press d (RIGHT)';
                }
                
                // Update the status with large, clear instructions
                this.updateStatus(`ü§ñ MANUAL: ${commandText} on interactive control`, 'warning');
                
                // Also show in the status overlay
                const statusOverlay = document.getElementById('statusOverlay');
                if (statusOverlay) {
                    statusOverlay.innerHTML = `
                        <div style="color: #ffaa00; font-weight: bold; font-size: 16px;">
                            ü§ñ MANUAL CONTROL
                        </div>
                        <div style="color: white; font-size: 18px; margin-top: 5px;">
                            ${commandText}
                        </div>
                        <div style="color: #888; font-size: 12px; margin-top: 5px;">
                            L: ${leftSpeed}, R: ${rightSpeed}
                        </div>
                    `;
                }
            }

            toggleVoiceControl() {
                this.voiceActive = !this.voiceActive;
                const voiceBtn = document.getElementById('voiceBtn');
                
                if (this.voiceActive) {
                    voiceBtn.classList.add('active');
                    voiceBtn.textContent = 'üé§ Stop Voice';
                    this.startVoiceRecognition();
                    this.updateStatus('üé§ Voice control active - speak to me!', 'success');
                } else {
                    voiceBtn.classList.remove('active');
                    voiceBtn.textContent = 'üé§ Voice Control';
                    this.stopVoiceRecognition();
                    this.updateStatus('üé§ Voice control disabled', 'status');
                }
            }
            
            startVoiceRecognition() {
                try {
                    // Initialize speech recognition
                    if ('webkitSpeechRecognition' in window) {
                        this.recognition = new webkitSpeechRecognition();
                        console.log('üé§ Using webkitSpeechRecognition');
                    } else if ('SpeechRecognition' in window) {
                        this.recognition = new SpeechRecognition();
                        console.log('üé§ Using SpeechRecognition');
                    } else {
                        this.updateStatus('‚ùå Speech recognition not supported in this browser', 'error');
                        alert('Speech recognition not supported. Try using Chrome browser.');
                        return;
                    }
                    
                    // Configure recognition
                    this.recognition.continuous = false; // Changed to false for better reliability
                    this.recognition.interimResults = false;
                    this.recognition.lang = 'en-US';
                    this.recognition.maxAlternatives = 1;
                    
                    this.recognition.onstart = () => {
                        console.log('üé§ Voice recognition started - speak now!');
                        this.updateStatus('üé§ Listening... speak now!', 'success');
                    };
                    
                    this.recognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript.trim();
                        const confidence = event.results[0][0].confidence;
                        console.log(`üé§ Heard: "${transcript}" (confidence: ${confidence})`);
                        this.updateStatus(`üé§ Heard: "${transcript}"`, 'warning');
                        this.processVoiceCommand(transcript);
                    };
                    
                    this.recognition.onerror = (event) => {
                        console.error('üö® Speech recognition error:', event.error);
                        if (event.error === 'not-allowed') {
                            this.updateStatus('‚ùå Microphone permission denied. Allow microphone access and try again.', 'error');
                            alert('Please allow microphone access and try again!');
                        } else if (event.error === 'no-speech') {
                            this.updateStatus('üé§ No speech detected. Try again.', 'warning');
                        } else {
                            this.updateStatus(`‚ùå Speech error: ${event.error}`, 'error');
                        }
                    };
                    
                    this.recognition.onend = () => {
                        console.log('üé§ Voice recognition ended');
                        if (this.voiceActive) {
                            // Restart recognition automatically after 1 second
                            setTimeout(() => {
                                if (this.voiceActive) {
                                    console.log('üîÑ Restarting voice recognition...');
                                    this.recognition.start();
                                }
                            }, 1000);
                        }
                    };
                    
                    // Start recognition
                    this.recognition.start();
                    console.log('üé§ Voice recognition initialized and started');
                    
                } catch (error) {
                    console.error('‚ùå Voice recognition setup error:', error);
                    this.updateStatus('‚ùå Voice recognition setup failed: ' + error.message, 'error');
                }
            }
            
            stopVoiceRecognition() {
                if (this.recognition) {
                    this.recognition.stop();
                    this.recognition = null;
                }
            }
            
            async processVoiceCommand(text) {
                try {
                    console.log(`üéØ Processing: "${text}"`);
                    this.updateStatus(`üé§ Processing: "${text}"`, 'warning');
                    
                    // Send to voice AI server
                    const serverIP = window.location.hostname;
                    const response = await fetch(`http://${serverIP}:8083/voice/process`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: text })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('ü§ñ Voice AI response:', result);
                        
                        // Speak the response
                        await this.speakResponse(result.response_text);
                        
                        // Handle special actions
                        if (result.robot_action === 'start_following') {
                            if (!this.followingActive) this.toggleFollowing();
                        } else if (result.robot_action === 'stop_following') {
                            if (this.followingActive) this.toggleFollowing();
                        }
                        
                        this.updateStatus(`ü§ñ ${result.response_text}`, 'success');
                        
                    } else {
                        this.updateStatus('‚ùå Voice command failed', 'error');
                    }
                    
                } catch (error) {
                    console.error('Voice command error:', error);
                    this.updateStatus('‚ùå Voice processing error', 'error');
                }
            }
            
            async speakResponse(text) {
                try {
                    // Try ElevenLabs first
                    const serverIP = window.location.hostname;
                    const response = await fetch(`http://${serverIP}:8083/voice/speak`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: text })
                    });
                    
                    if (response.ok) {
                        const audioBlob = await response.blob();
                        if (audioBlob.size > 0) {
                            const audioUrl = URL.createObjectURL(audioBlob);
                            const audio = new Audio(audioUrl);
                            audio.play();
                            console.log(`üîä ElevenLabs speaking: "${text}"`);
                            return;
                        }
                    }
                } catch (error) {
                    console.log('ElevenLabs failed, using browser TTS:', error);
                }
                
                // Fallback to browser speech synthesis
                try {
                    if ('speechSynthesis' in window) {
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.rate = 0.9;
                        utterance.pitch = 1.0;
                        utterance.volume = 1.0;
                        
                        // Try to use a good voice
                        const voices = speechSynthesis.getVoices();
                        const goodVoice = voices.find(voice => 
                            voice.name.includes('Samantha') || 
                            voice.name.includes('Alex') || 
                            voice.name.includes('Google')
                        );
                        if (goodVoice) utterance.voice = goodVoice;
                        
                        speechSynthesis.speak(utterance);
                        console.log(`üîä Browser TTS speaking: "${text}"`);
                    }
                } catch (error) {
                    console.error('All speech synthesis failed:', error);
                }
            }

            updateStatus(message, className = 'status') {
                this.status.textContent = message;
                this.status.className = `status ${className}`;
            }
        }

        // Initialize the red cap follower
        document.addEventListener('DOMContentLoaded', () => {
            new RedCapFollower();
        });
    </script>
</body>
</html>
